<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>objectc之runtime四川兄原创 | iOS黑夜之路</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="object-c之runtime最近看了些关于object-c（以下简称oc）的runtime文章，了解了些oc的原理，下面阐述下oc的一些机制
引：\toc是一门简单的语言，95%是C。只是在语言层面上加了些关键字和语法。真正让oc如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。\t1、runtime是开源的。可以去down：http://opensource.apple.com">
<meta property="og:type" content="article">
<meta property="og:title" content="objectc之runtime四川兄原创">
<meta property="og:url" content="http://reqianduan.com//2014/07/27/2014072511/">
<meta property="og:site_name" content="iOS黑夜之路">
<meta property="og:description" content="object-c之runtime最近看了些关于object-c（以下简称oc）的runtime文章，了解了些oc的原理，下面阐述下oc的一些机制
引：\toc是一门简单的语言，95%是C。只是在语言层面上加了些关键字和语法。真正让oc如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。\t1、runtime是开源的。可以去down：http://opensource.apple.com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="objectc之runtime四川兄原创">
<meta name="twitter:description" content="object-c之runtime最近看了些关于object-c（以下简称oc）的runtime文章，了解了些oc的原理，下面阐述下oc的一些机制
引：\toc是一门简单的语言，95%是C。只是在语言层面上加了些关键字和语法。真正让oc如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。\t1、runtime是开源的。可以去down：http://opensource.apple.com">

  
    <link rel="alternative" href="/atom.xml" title="iOS黑夜之路" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iOS黑夜之路</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">iOS黑夜之路官方博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://reqianduan.com/"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2014072511" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/27/2014072511/" class="article-date">
  <time datetime="2014-07-27T01:48:49.000Z" itemprop="datePublished">Jul 27 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ios/">ios</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      objectc之runtime四川兄原创
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>﻿object-c之runtime<br>最近看了些关于object-c（以下简称oc）的runtime文章，了解了些oc的原理，下面阐述下oc的一些机制</p>
<p>引：<br>\toc是一门简单的语言，95%是C。只是在语言层面上加了些关键字和语法。真正让oc如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。<br>\t1、runtime是开源的。可以去down：<a href="http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz" target="_blank" rel="external">http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz</a><br>\t2、runtime是（基本上，还有部分是汇编，反正很多都是各种宏，in my opinion）由C语言实现的。<br>\t3、runtime的两个版本。（这个不知道要表达个什么，大概是些历史什么的）</p>
<p>归纳了下，oc的核心思想是消息机制，先说在这。</p>
<p>讲下oc里类的原理。首先我们看他对类的定义:<br>typedef struct objc_class <em>Class;<br>typedef struct objc_object {<br>    Class isa;<br>} </em>id;</p>
<p>大多数面向对象的语言里有 classes 和 objects 的概念。Objects通过Classes生成。但是在Objective-C中，classes本身也是objects(译者注：这点跟python很像)，也可以处理消息，这也是为什么会有类方法和实例方法。具体来说，Objective-C中的Object是一个结构体(struct)，第一个成员是isa，指向自己的class。这是在objc/objc.h中定义的。</p>
<p>object的class保存了方法列表，还有指向父类的指针。但classes也是objects，也会有isa变量，那么它又指向哪儿呢？这里就引出了第三个类型: metaclasses。一个 metaclass被指向class，class被指向object。它保存了所有实现的方法列表，以及父类的metaclass<br>这个的定义在runtime.h里：<br>这里引入一段精辟的看不大清楚的话（Objective-C is a class-based object system. Each object is an instance of some class; the object\’s isa pointer points to its class. That class describes the object\’s data: allocation size and ivar types and layout. The class also describes the object\’s behavior: the selectors it responds to and instance methods it implements.）<br>struct objc_class {<br>    Class isa  OBJC_ISA_AVAILABILITY;</p>
<h1 id="if_!OBJC2">if !<strong>OBJC2</strong></h1>
<pre><code>Class super_class                                        OBJC2_UNAVAILABLE;
<span class="keyword">const</span> <span class="built_in">char</span> *name                                         OBJC2_UNAVAILABLE;
<span class="built_in">long</span> <span class="keyword">version</span>                                             OBJC2_UNAVAILABLE;
<span class="built_in">long</span> info                                                OBJC2_UNAVAILABLE;
<span class="built_in">long</span> instance_size                                       OBJC2_UNAVAILABLE;
<span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
<span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
<span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;
<span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
</code></pre><h1 id="endif">endif</h1>
<p>} OBJC2_UNAVAILABLE;</p>
<p>从中可以清楚的看到一个Class到底里面是些什么东西，父类，名字，还有一堆我们关心的方法，协议，缓存数据等（还有几个，我不好意思说）。<br>可以看到方法协议，什么的都用的还是struct。</p>
<p>下面我捡一些好听的来说。<br>当然我们肯定关心的是方法，首先看下方法列表的定义：</p>
<p>struct objc_method_list {<br>    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</p>
<pre><code><span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;
</code></pre><h1 id="ifdef_LP64">ifdef <strong>LP64</strong></h1>
<pre><code><span class="built_in">int</span> <span class="built_in">space</span>                                                OBJC2_UNAVAILABLE;
</code></pre><h1 id="endif-1">endif</h1>
<pre><code><span class="comment">/* variable length structure */</span>
<span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;
</code></pre><p>}                                                            OBJC2_UNAVAILABLE;</p>
<p>大概是什么捏，我也看不大明白，没事继续看下方法的具体定义：<br>struct objc_method {<br>    SEL method_name                                          OBJC2_UNAVAILABLE;<br>    char *method_types                                       OBJC2_UNAVAILABLE;<br>    IMP method_imp                                           OBJC2_UNAVAILABLE;<br>}                                                            OBJC2_UNAVAILABLE;</p>
<p>这下差不多了，这是具体方法的定义。这个内部的剖析，等下在说，先绕开往下说下objc_cache。<br>看看objc_cache的定义：</p>
<p>struct objc_cache {<br>    unsigned int mask /<em> total = mask + 1 </em>/                 OBJC2_UNAVAILABLE;<br>    unsigned int occupied                                    OBJC2_UNAVAILABLE;<br>    Method buckets[1]                                        OBJC2_UNAVAILABLE;<br>} /<em> GrP fixme should be OBJC2_UNAVAILABLE, but isn\’t because of spurious warnings in [super …] calls </em>/;</p>
<p>等下，这有个Method有点蕾丝objc_method哈，于是找到这个定义：<br>typedef struct objc_method *Method;<br>联系上鸟。</p>
<p>好吧，不绕了，讲讲方法吧，这里也就是上面要涉及但憋回去的消息机制。<br>说起方法就不得不说他的机制，oc里的方法就是消息，Look：</p>
<p>NSMutableArray *arr = [NSMutableArray arrayWithObjects:@\”dd\”, nil];<br>[arr addObject:@\”k\”];<br>objc_msgSend(arr, @selector(addObject:),@\”pp\”);<br>NSLog(@\”arr:%@\”,arr);</p>
<p>他们可以等价，调用array的insertObject的方法，参数分别是foo,5。上面就是典型的oc试，下面就是等价的消息模式，亲侧可行，前提是你得引入消息模式的文件。</p>
<h1 id="if_TARGET_IPHONE_SIMULATOR">if TARGET_IPHONE_SIMULATOR</h1>
<h1 id="import_">import <objc objc-runtime.h=""></objc></h1>
<h1 id="else">else</h1>
<h1 id="import_-1">import <objc runtime.h=""></objc></h1>
<h1 id="import_-1">import <objc message.h=""></objc></h1>
<h1 id="endif-2">endif</h1>
<p>这就是引入。</p>
<p>跑了有点裤子穿偏了，回过神来继续说这个objc_method,逐个说下<br>SEL 类成员方法的指针：<br>可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Object-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.<br>可以用这个NSSelectorFromString直接取,NSStringFromSelector反转。</p>
<p>简单说就是函数的地址，只不过函数的地址和函数实现的地址不在同一个地方。</p>
<p>method_types 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表</p>
<p>method_imp 之 IMP 是”implementation”的缩写，它是objetive-C 方法(method)实现代码块的地址，可像C函数一样直接调用。通常情况下我们是通过[object method:parameter]或objc_msgSend()的方式向对象发送消息，然后Objective-C运行时(Objective-C runtime)寻找匹配此消息的IMP,然后调用它;但有些时候我们希望获取到IMP进行直接调用。</p>
<p>简单来说method_imp就是函数实现的代码块地址。</p>
<p>方法大概就这些，接下来就说下，对象是怎么找到方法的，这里涉及到一些原理，我们可以假装不知道的。<br>当一个对象去执行某一个方法的时候，首先去是cache里找method，因为这个最快（他们都是存到hash里的），当找不到的时候才去那个objc_method_list里找，如果还没有就去super_class里找，这样循环到根上也就是NSObject，还是没有就不好意思crash了。</p>
<p>接下来说下平常coding有用的东西了</p>
<p>class开头的方法是用来修改和自省classes。方法如class_addIvar, class_addMethod, class_addProperty和class_addProtocol允许重建classes。class_copyIvarList, class_copyMethodList, class_copyProtocolList和class_copyPropertyList能拿到一个class的所有内容。而class_getClassMethod, class_getClassVariable, class_getInstanceMethod, class_getInstanceVariable, class_getMethodImplementation和class_getProperty返回单个内容。</p>
<p>假设我要取回去某个对象的属性或者方法：<br>uint attrCount = 0,selfCount = 0;<br>objc_property_t <em>attrs = class_copyPropertyList([self class], &amp;attrCount);<br>Method </em>method =  class_copyMethodList([self class], &amp;selfCount);<br>for (int i=0;i&lt;=count;++i) {<br>        objc_property_t property = attrs[i];<br>        NSLog(@\”key:%s,value:%@\”,property_getName(property),[self valueForKey:[NSString stringWithFormat:@\”%s\”,property_getName(property)]]);<br>}<br>for (int i=0;i&lt;=count1;++i) {<br>    SEL sel = method_getName(method[i]);<br>    IMP imp = method_getImplementation(method[i]);<br>    NSLog(@\”sel:%s\”,sel_getName(sel));<br>}</p>
<p>这些都不算啥，现在说点动态的东西，比如动态添加属性，动态添加方法。</p>
<p>这里其实我们需要用class_addMethod就可以了。</p>
<p>这里有必要说下<br>+(BOOL)resolveInstanceMethod:(SEL)sel;<br>和<br>+(BOOL)resolveClassMethod:(SEL)sel;<br>字面上来说，一个是对象方法，一个是类方法，都是消息转发机制前调用的。</p>
<p>意思是如果我们劫持重写这个，就可以添加一切我们想要的方法。<br>下面拿一个世界上最干净的类之一来说事：</p>
<p>@interface DB : NSObject<br>@end<br>@implementation DB<br>@end</p>
<p>如果我现在<br>DB *d = [DB new];<br>[d alert];<br>有人要说我傻x了，好吧，我牺牲自己引入下文：</p>
<p>对，我们上面说到了劫持，所以我就继承了这个方法，并重写了下</p>
<p>ex：<br>//这个就是alert函数实现的地方。<br>ps:这里得多说几句，第一个参数是消息的发起方，就对象，self就是方法的指针。必须的，后面的参数就跟着依次。<br>void defineIMPForAlert(id self,SEL _cmd){<br>    NSLog(@\”xxxx\”);<br>}<br>ps:这里可以通过重写这个，当然也可以在外面直接用class_addMethod.<br>+(BOOL)resolveInstanceMethod:(SEL)sel{<br>//当在调用alert的时候，会自动添加这个方法进去。<br>    if(sel == @selector(alert)){<br>    //这里就劫持了并添加并实现了我想要的方法。最后那个参数是个奇葩见(1)说明。</p>
<pre><code>    class_addMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>],<span class="title">sel</span>,(<span class="title">IMP</span>)<span class="title">defineIMPForAlert</span>,[@\"<span class="title">v</span>@:\" <span class="title">UTF8String</span>]);</span>
    <span class="keyword">return</span> <span class="constant">YES</span>;
}
<span class="keyword">return</span> [<span class="keyword">super</span> <span class="symbol">resolveClassMethod:</span>sel];
</code></pre><p>}</p>
<p>哈。我的对象就具备了alert的方法。也就是说我的对象就可以来发送alert的消息。好吧，就是说我[d performSelector:@selector(alert)];就合法了(注意这里不能直接写[d alert]，因为我那个是动态添加的应该是说要在运行的时候才有alert方法，所以ide并不知道，编译也不会让你过)。尽管我什么alert都没定义。</p>
<p>记得上面说过属性也可以，是的，属性也可以。但网上的栗子都没成熟，所以，我就先放一个我测试过了的（看起来有点不舒服的栗子）。<br>NSString<em> name(id self,SEL _cmd){<br>    return objc_getAssociatedObject(self, @\”name\”);<br>}<br>void setName(id self,SEL _cmd,NSString </em>name){<br>    objc_setAssociatedObject(self, @\”name\”, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}<br>class_addMethod([DB class],@selector(name),(IMP)name,[@\”@@:\” UTF8String]);<br>class_addMethod([DB class],@selector(setName:),(IMP)setName,[@\”v@:@\” UTF8String]);</p>
<p>这样我就可以</p>
<p>[d performSelector:@selector(setName:) withObject:@\”ddd\”];<br>NSLog(@\”self.name:%@\”,[d performSelector:@selector(name)]);</p>
<p>下面是些扩展用法。</p>
<p>@interface CC : NSObject<br>-(void)say;<br>-(void)sing;<br>@end</p>
<p>@implementation CC<br>-(void)say{<br>    NSLog(@\”os\”);<br>}<br>-(void)sing{<br>    NSLog(@\”sn\”);<br>}<br>@end</p>
<p>BB <em>b = [BB new];<br>//我让b去继承cc的<br>object_setClass(b, [CC class]); //实现方法。见(2)<br>//于是b就有了say的方法<br>[b performSelector:@selector(say)];<br>CC </em>c = [CC new];<br>//获取say的方法<br>Method methodSay = class_getInstanceMethod([c class], @selector(say));<br>Method methodSing = class_getInstanceMethod([c class], @selector(sing));<br>//交换2个方法<br>method_exchangeImplementations(methodSay, methodSing); //实现方法。见(3)<br>//于是有了结果的变化<br>[c say];<br>[c sing];<br>//b也跟着变了<br>[b performSelector:@selector(say)];</p>
<p>以上。</p>
<p>(1)<br>c char<br>i  int<br>s short<br>l long<br>l is treated as a 32-bit quantity on 64-bit programs.<br>q long long<br>C unsigned char<br>I unsigned int<br>S unsigned short<br>L unsigned long<br>Q unsigned long long<br>f float<br>d double<br>B C++ bool or a C99 _Bool<br>v void</p>
<ul>
<li>character string (char *)<br>@ object (whether statically typed or typed id)<h1 id="class_object_(Class)">class object (Class)</h1>
: method selector (SEL)<br>[array type] array<br>{name=type…} structure<br>(name=type…) A union<br>bnum bit field of num bits<br>^type pointer to type<br>? An unknown type (among other things, this code is used for function pointers)<br>PS:貌似@：组成了返回类型和形参的分割线。</li>
</ul>
<p>(2)</p>
<p>Class object_setClass(id obj, Class cls)<br>{<br>    if (obj) {<br>        Class old;<br>        do {<br>            old = obj-&gt;isa;<br>        } while (! OSAtomicCompareAndSwapPtrBarrier(old, cls, (void*)&amp;obj-&gt;isa));<br>        return old;<br>    }<br>    else return Nil;<br>}</p>
<p>(3)<br>void method_exchangeImplementations(Method m1_gen, Method m2_gen)<br>{<br>    IMP m1_imp;<br>    struct old_method <em>m1 = _method_asOld(m1_gen);<br>    struct old_method </em>m2 = _method_asOld(m2_gen);<br>    if (!m1  ||  !m2) return;</p>
<pre><code><span class="keyword">if</span> (m1-&gt;method_name == (SEL)kIgnore  ||  m2-&gt;method_name == (SEL)kIgnore) {
    <span class="comment">// Ignored methods stay ignored. Now they\'re both ignored.</span>
    m1-&gt;method_imp = (IMP)&amp;<span class="number">_</span>objc_ignored_method;
    m2-&gt;method_imp = (IMP)&amp;<span class="number">_</span>objc_ignored_method;
    <span class="keyword">return</span>;
}


OSSpinLockLock(&amp;impLock);
m1_imp = m1-&gt;method_imp;
m1-&gt;method_imp = m2-&gt;method_imp;
m2-&gt;method_imp = m1_imp;
OSSpinLockUnlock(&amp;impLock);
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://reqianduan.com/2014/07/27/2014072511/" data-id="n0fvk2d12h6at7wx" class="article-share-link">Share</a>
      
        <a href="http://reqianduan.com/2014/07/27/2014072511/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/07/27/2014072522/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微信支付
        
      </div>
    </a>
  
  
    <a href="/2014/07/27/2014072520/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数组归类前提是已经排序好笑脸</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a><span class="category-list-count">25</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">25</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ios/" style="font-size: NaNpx;">ios</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">July 2014</a><span class="archive-list-count">25</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/07/27/201407251/">FacebookPaper使用的第三方库输入兄转帖</a>
          </li>
        
          <li>
            <a href="/2014/07/27/201407250/">9款优秀的免费测试框架帮你揪出app中的臭虫时光转帖</a>
          </li>
        
          <li>
            <a href="/2014/07/27/201407259/">ios手势密码四川兄原创</a>
          </li>
        
          <li>
            <a href="/2014/07/27/201407258/">iOS开发各种库各种工具包输入兄转载</a>
          </li>
        
          <li>
            <a href="/2014/07/27/201407257/">iOS开发常用的第三方类库时光转帖</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://lwgarmstrong.github.io">lwgarmstrong</a>
          </li>
        
          <li>
            <a href="http://songbai1211.github.io">baige</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 zhang song bai<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank" rel="external nofollow">Hexo</a>
      .
      Theme by <a href="http://xiguabaobao.com/" target="_blank" rel="external nofollow">西瓜宝宝</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'reqianduan';
  
  var disqus_url = 'http://reqianduan.com/2014/07/27/2014072511/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>



<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>